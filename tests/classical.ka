
data And : * -> * -> *
    { and : [A B : *] -> A -> B -> And A B }

fst [A B : *] [x : And A B] : A => (
    And-Elim A B x (\A _ _ => A) (\_ _ a _ => a)
)

snd [A B : *] [x : And A B] : B => (
    And-Elim A B x (\_ B _ => B) (\_ _ _ b => b)
)

data Or : * -> * -> *
    { inl : [A B : *] -> A -> Or A B
    | inr : [A B : *] -> B -> Or A B
    }

case [A B C : *] [x : Or A B] [f : A -> C] [g : B -> C] : C => (
    Or-Elim A B x
        (\A B _ => [C : *] -> (A -> C) -> (B -> C) -> C)
        (\_ _ y _ f _ => f y)
        (\_ _ y _ _ f => f y)
        C f g
)

data Bot : * { }

absurd [p : Bot] [A : *] : A => (
    Bot-Elim p (\_ => A)
)

not [A : *] : * => (A -> Bot)

em-dn [em : [A : *] -> Or A (not A)] [A : *] [nnA : not (not A)] : A => (
    case A (not A) A (em A) (\a => a) (\nota => absurd (nnA nota) A)
)

dn-em [dn : [A : *] -> not (not A) -> A] [A : *] : Or A (not A) => (
    dn (Or A (not A)) (\x => x (inr A (not A) (\y => x (inl A (not A) y))))
)
