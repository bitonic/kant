
data Nat : Type { zero | suc Nat }

one : Nat => (suc zero)
two : Nat => (suc one)
three : Nat => (suc two)

plus | [x y : Nat] : Nat => (
  case x return Nat
    { zero   => y
    | suc x' => suc (plus x' y)
    }
)

times | [x y : Nat] : Nat => (
  case x return Nat
    { zero   => zero
    | suc x' => plus y (times x' y)
    }
)

data List [A : Type] : Type { nil | cons A (List A) }

app [A : Type] | [xs ys : List A] : List A => (
  case xs return List A
    { nil        => ys
    | cons x xs' => cons A x (app A xs' ys)
    }
)

map [A B : Type] [f : A -> B] | [xs : List A] : List B => (
  case xs return List B
    { nil        => nil B
    | cons x xs' => cons B (f x) (map A B f xs')
    }
)

upto3 : List Nat => (cons Nat one (cons Nat two (cons Nat three (nil Nat))))

upto4 : List Nat => (cons Nat one (map Nat Nat (plus one) upto3))

-- data Sigma [A : Type] [B : A -> Type] : Type
--   { si [x : A] (B x) }

-- fst [A : Type] [B : A -> Type] [x : Sigma A B] : A => (
--   case x return A { si y _ => y }
-- )

-- snd [A : Type] [B : A -> Type] [x : Sigma A B] : B (fst A B x) => (
--   case x return B (fst A B x) { si _ y => y }
-- )

id [A : Type] [x : A] : A => x
const [A B : Type] [x : A] B : A => x

data Bool : Type { true | false }

ite [A : Type] [B : Bool -> Type] [b : Bool] [x : B true] [y : B false] : B b => (
  case b return B b
    { true => x | false => y }
)

ite' [A : Type] [B : Type] : Bool -> B -> B -> B => (
  ite A (\Bool => B)
)

data Empty : Type { }

data Unit : Type { tt }

T [b : Bool] : Type => (ite' b Unit Empty)

absurd [bot : Empty] [A : Type] : A => (case bot return A { })

ackerman | [m n : Nat] : Nat => (
  case m return Nat
    { zero   => suc n
    | suc m' => case n return Nat
                  { zero   => ackerman m' one
                  | suc n' => ackerman m' (ackerman m n')
                  }
    }
)

postulate empty : Empty
