
data Nat : * { zero : Nat | suc : Nat -> Nat }

one : Nat => (suc zero)
two : Nat => (suc one)
three : Nat => (suc two)

plus [x : Nat] : Nat -> Nat => (
   Nat-Elim
       x                        -- Thing to eliminate
       (\_ => Nat -> Nat)       -- Return type
       (\y => y)                -- Base case, if x is zero
       (\_ f y => suc (f y))    -- Inductive step
)

times [x : Nat] : Nat -> Nat => (
    Nat-Elim x (\_ => Nat -> Nat)
        (\_ => zero)
        (\_ f y => plus y (f y))
)

fac [x : Nat] : Nat => (
    Nat-Elim x (\_ => Nat) one (\ n rec => times (suc n) rec)
)

data List : [A : *] -> *
    { nil  : List A
    | cons : A -> List A -> List A
    }

app [A : *] [xs : List A] : List A -> List A => (
    List-Elim A xs
        (\A _ => List A -> List A)
        (\_ ys => ys)
        (\A x _ f ys => cons A x (f ys))
)

map [A : *] [xs : List A] : [B : *] -> (A -> B) -> List B => (
    List-Elim A xs
        (\A _ => [B : *] -> (A -> B) -> List B)
        (\_ B _ => nil B)
        (\_ x xs rec B f => cons B (f x) (rec B f))
)

length [A : *] [xs : List A] : Nat => (
    List-Elim A xs
        (\A _ => Nat)
        (\_ => zero)
        (\_ _ _ n => suc n)
)

upto3 : List Nat => (cons Nat one (cons Nat two (cons Nat three (nil Nat))))

upto4 : List Nat => (cons Nat zero (map Nat upto3 Nat (plus one)))

data Sigma : [A : *] [B : A -> *] -> *
     { si : [x : A] -> B x -> Sigma A B }

fst [A : *] [B : A -> *] [x : Sigma A B] : A => (
    Sigma-Elim A B x (\A _ _ => A) (\_ _ x _ => x)
)

snd [A : *] [B : A -> *] [x : Sigma A B] : B (fst A B x) => (
    Sigma-Elim A B x (\A B x => B (fst A B x)) (\_ _ _ x => x)
)

id [A : *] [x : A] : A => x
const [A B : *] [x : A] [y : B] : A => x

data Bool : * { true : Bool | false : Bool }

ite [P : Bool -> *] [b : Bool] : P true -> P false -> P b => (
    Bool-Elim b P
)

ite' [A : *] : Bool -> A -> A -> A => (ite (\_ => A))

data Empty : * { }

absurd [p : Empty] [A : *] : A => (
    Empty-Elim p (\_ => A)
)

data Unit : * { tt : Unit }

T [b : Bool] : * => (ite' * b Unit Empty)

-- ackerman | [m n : Nat] : Nat => (
--   case m return Nat
--     { zero   => suc n
--     | suc m' => case n return Nat
--                   { zero   => ackerman m' one
--                   | suc n' => ackerman m' (ackerman m n')
--                   }
--     }
-- )

isZero [n : Nat] : Bool => (
  Nat-Elim n (\_ => Bool) true (\_ _ => false)
)

isSuc [n : Nat] : Bool => (
  Nat-Elim n (\_ => Bool) false (\_ _ => true)
)

not [b : Bool] : Bool => (
  ite' Bool b false true
)

pred [n : Nat] : T (isSuc n) -> Nat => (
    Nat-Elim n (\m => T (isSuc m) -> Nat) (\p => absurd p Nat) (\m _ _ => m)
)

-- data Fin : Nat -> *
--     { fzero : [n : Nat]          -> Fin (suc n)
--     | fsuc  : [n : Nat] -> Fin n -> Fin (suc n)
--     }

-- fzero-absurd [fz : Fin zero] [A : *] : A => (
--     Fin-Elim zero fz
--         (\n _ => ite' * (isZero n) A Unit)
--         (\_ => tt)
--         (\_ _ _ => tt)
-- )

-- Fin-case [n : Nat] [m : Fin (suc n)] : [A : *] -> A -> (Fin n -> A) -> A => (
--     Fin-Elim (suc n) m
--         (\_ _ => [A : *] -> A -> (Fin n -> A) -> A)
--         {!hfc1!}
--         {!hfc2!}
-- )

-- ix [A : *] [xs : List A] : Fin (length A xs) -> A => (
--     List-Elim A xs
--         (\A ys => Fin (length A ys) -> A)
--         (\A fz => fzero-absurd fz A)
--         (\A x ys f m => Fin-case (length A ys) m A x f)
-- )

-- data Eq : [A : *] -> A -> A -> *
--   { refl : [A : *] [x : A] -> Eq A x x }

-- subst [A : *] [x y : A] [p : Eq A x y] : [P : A -> *] -> P x -> P y => (
--     Eq-Elim A x y p
--         (\A x y p => [P : A -> *] -> P x -> P y)
--         (\A _ _ p => p)
-- )
