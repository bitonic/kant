
data Nat : Type { zero | suc Nat }

one : Nat => (suc zero)
two : Nat => (suc one)
three : Nat => (suc two)

plus | [x y : Nat] : Nat => (
  case x return Nat
    { zero   => y
    | suc x' => suc (plus x' y)
    }
)

times | [x y : Nat] : Nat => (
  case x return Nat
    { zero   => zero
    | suc x' => plus y (times x' y)
    }
)

data List [A : Type] : Type { nil | cons A (List A) }

app [A : Type] | [xs ys : List A] : List A => (
  case xs return List A
    { nil        => ys
    | cons x xs' => cons A x (app A xs' ys)
    }
 )

map [A B : Type] [f : A -> B] | [xs : List A] : List B => (
  case xs return List B
    { nil        => nil B
    | cons x xs' => cons B (f x) (map A B f xs')
    }
)

length [A : Type] | [xs : List A] : Nat => (
  case xs return Nat
    { nil        => zero
    | cons _ xs' => suc (length A xs')
    }
)

upto3 : List Nat => (cons Nat one (cons Nat two (cons Nat three (nil Nat))))

upto4 : List Nat => (cons Nat one (map Nat Nat (plus one) upto3))

data Sigma [A : Type] [B : A -> Type] : Type { si [x : A] (B x) }

fst [A : Type] [B : A -> Type] [x : Sigma A B] : A => (
  case x return A { si y _ => y }
)

snd [A : Type] [B : A -> Type] [x : Sigma A B] : B (fst A B x) => (
  case x return B (fst A B x) { si _ y => y }
)

id [A : Type] [x : A] : A => x
const [A B : Type] [x : A] B : A => x

data Bool : Type { true | false }

ite [P : Bool -> Type] [b : Bool] [x : P true] [y : P false] : P b => (
  case b return P b
    { true => x | false => y }
)

ite' [A : Type] : Bool -> A -> A -> A => (
  ite (\Bool => A)
)

data Empty : Type { }

data Unit : Type { tt }

T [b : Bool] : Type => (ite' Type b Unit Empty)

absurd [bot : Empty] [A : Type] : A => (case bot return A { })

ackerman | [m n : Nat] : Nat => (
  case m return Nat
    { zero   => suc n
    | suc m' => case n return Nat
                  { zero   => ackerman m' one
                  | suc n' => ackerman m' (ackerman m n')
                  }
    }
)

isZero [n : Nat] : Bool => (
  case n return Bool
    { zero  => true
    | suc _ => false
    }
)

isSuc [n : Nat] : Bool => (
  case n return Bool
    { zero  => false
    | suc _ => true
    }
)

not [b : Bool] : Bool => (
  case b return Bool { true => false | false => true }
)

pred [n : Nat] [p : T (isSuc n)] : Nat => (
  case n return Nat
    { zero   => absurd p Nat
    | suc n' => n'
    }
)

data Fin [n : Nat] : Type
  { fzero (isSuc n)
  | fsuc [p : T (isSuc n)] (Fin (pred n p))
  }
