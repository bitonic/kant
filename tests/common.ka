
data Nat : Type { zero | suc Nat }

one : Nat := (suc zero)

plus [x y : Nat] : Nat := (
  case x { zero   => y
         | suc x' => suc (plus x' y)
         }
)

times [x y : Nat] : Nat := (
  case x { zero   => zero
         | suc x' => plus y (times x' y)
         }
)

data List [A : Type] : Type
  { nil | cons A (List A) }

app [xs ys : List A] : List A := (
  case xs { nil        => ys
          | cons x xs' => cons x (app xs' ys)
          }
)

id [A : Type] [x : A] : A := x
const [A B : Type] [x : A] B : A := x

data Bool : Type { true | false }

ite [A : Type] [B : Bool -> Type] [b : Bool] [x : B true] [y : B false] : B b := (
  case b { true => x | false => y }
)

ite' [A : Type] [B : Type] [b : Bool] [x y : B] : B := (
  ite A (const A) b x y
)

data Empty : Type { }

data Unit : Type { tt }

T [b : Bool] : Type := (ite' b Unit Empty)

absurd [bot : Empty] [A : Type] : A := (case bot { })

ackerman [m n : Nat] : Nat := (
  case m { zero   => suc n
         | suc m' => case n { zero   => ackerman m' one
                            | suc n' => ackerman m' (ackerman m n')
                            }
         }
)

postulate empty : Empty
