
data Nat : Type { zero : Nat | suc : Nat -> Nat }

one : Nat => (suc zero)
two : Nat => (suc one)
three : Nat => (suc two)

plus [x : Nat] : Nat -> Nat => (
   Nat-Elim
       x                        -- Thing to eliminate
       (\_ => Nat -> Nat)       -- Return type
       (\y => y)                -- Base case, if x is zero
       (\_ f y => suc (f y))    -- Inductive step
)

times [x : Nat] : Nat -> Nat => (
    Nat-Elim
        x
        (\_ => Nat -> Nat)
        (\_ => zero)
        (\_ f y => plus y (f y))
)

data List : Type -> Type
    { nil  : [A : Type]                -> List A
    | cons : [A : Type] -> A -> List A -> List A
    }

app [A : Type] [xs : List A] : List A -> List A => (
    List-Elim
        A
        xs
        (\A _ => List A -> List A)
        (\_ ys => ys)
        (\A x _ f ys => cons A x (f ys))
)

map [A : Type] [xs : List A] : [B : Type] -> (A -> B) -> List B => (
    List-Elim A xs
        (\A _ => [B : Type] -> (A -> B) -> List B)
        (\_ B _ => nil B)
        (\_ x xs rec B f => cons B (f x) (rec B f))
)

length [A : Type] [xs : List A] : Nat => (
    List-Elim
        A
        xs
        (\A _ => Nat)
        (\_ => zero)
        (\_ _ _ n => suc n)
)

upto3 : List Nat => (cons Nat one (cons Nat two (cons Nat three (nil Nat))))

upto4 : List Nat => (cons Nat zero (map Nat upto3 Nat (plus one)))

data Sigma : [A : Type] [B : A -> Type] -> Type
     { si : [A : Type] [B : A -> Type] [x : A] -> B x -> Sigma A B }

fst [A : Type] [B : A -> Type] [x : Sigma A B] : A => (
    Sigma-Elim A B x (\A _ _ => A) (\_ _ x _ => x)
)

snd [A : Type] [B : A -> Type] [x : Sigma A B] : B (fst A B x) => (
    Sigma-Elim A B x (\A B x => B (fst A B x)) (\_ _ _ x => x)
)

id [A : Type] [x : A] : A => x
const [A B : Type] [x : A] [y : B] : A => x

data Bool : Type { true : Bool | false : Bool }

ite [P : Bool -> Type] [b : Bool] : P true -> P false -> P b => (
    Bool-Elim b P
)

ite' [A : Type] : Bool -> A -> A -> A => (
  ite (\_ => A)
)

data Empty : Type { }

absurd [p : Empty] [A : Type] : A => (
    Empty-Elim p (\_ => A)
)

data Unit : Type { tt : Unit }

T [b : Bool] : Type => (ite' Type b Unit Empty)

-- ackerman | [m n : Nat] : Nat => (
--   case m return Nat
--     { zero   => suc n
--     | suc m' => case n return Nat
--                   { zero   => ackerman m' one
--                   | suc n' => ackerman m' (ackerman m n')
--                   }
--     }
-- )

isZero [n : Nat] : Bool => (
  Nat-Elim n (\_ => Bool) true (\_ _ => false)
)

isSuc [n : Nat] : Bool => (
  Nat-Elim n (\_ => Bool) false (\_ _ => true)
)

not [b : Bool] : Bool => (
  ite' Bool b false true
)

pred [n : Nat] : T (isSuc n) -> Nat => (
    Nat-Elim n (\m => T (isSuc m) -> Nat) (\p => absurd p Nat) (\m _ _ => m)
)

data Fin : Nat -> Type
    { fzero : [n : Nat]          -> Fin (suc n)
    | fsuc  : [n : Nat] -> Fin n -> Fin (suc n)
    }


-- ix : [A : Type] [xs : List A] [n : Fin (length n)] : A => (

-- )
